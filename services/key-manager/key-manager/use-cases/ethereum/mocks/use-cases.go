// Code generated by MockGen. DO NOT EDIT.
// Source: use-cases.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	types "github.com/consensys/quorum/core/types"
	types0 "github.com/ethereum/go-ethereum/core/types"
	gomock "github.com/golang/mock/gomock"
	entities "gitlab.com/ConsenSys/client/fr/core-stack/orchestrate.git/pkg/types/entities"
	ethereum "gitlab.com/ConsenSys/client/fr/core-stack/orchestrate.git/services/key-manager/key-manager/use-cases/ethereum"
	big "math/big"
	reflect "reflect"
)

// MockUseCases is a mock of UseCases interface
type MockUseCases struct {
	ctrl     *gomock.Controller
	recorder *MockUseCasesMockRecorder
}

// MockUseCasesMockRecorder is the mock recorder for MockUseCases
type MockUseCasesMockRecorder struct {
	mock *MockUseCases
}

// NewMockUseCases creates a new mock instance
func NewMockUseCases(ctrl *gomock.Controller) *MockUseCases {
	mock := &MockUseCases{ctrl: ctrl}
	mock.recorder = &MockUseCasesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockUseCases) EXPECT() *MockUseCasesMockRecorder {
	return m.recorder
}

// CreateAccount mocks base method
func (m *MockUseCases) CreateAccount() ethereum.CreateAccountUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAccount")
	ret0, _ := ret[0].(ethereum.CreateAccountUseCase)
	return ret0
}

// CreateAccount indicates an expected call of CreateAccount
func (mr *MockUseCasesMockRecorder) CreateAccount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccount", reflect.TypeOf((*MockUseCases)(nil).CreateAccount))
}

// SignPayload mocks base method
func (m *MockUseCases) SignPayload() ethereum.SignUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignPayload")
	ret0, _ := ret[0].(ethereum.SignUseCase)
	return ret0
}

// SignPayload indicates an expected call of SignPayload
func (mr *MockUseCasesMockRecorder) SignPayload() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignPayload", reflect.TypeOf((*MockUseCases)(nil).SignPayload))
}

// SignTransaction mocks base method
func (m *MockUseCases) SignTransaction() ethereum.SignTransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignTransaction")
	ret0, _ := ret[0].(ethereum.SignTransactionUseCase)
	return ret0
}

// SignTransaction indicates an expected call of SignTransaction
func (mr *MockUseCasesMockRecorder) SignTransaction() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignTransaction", reflect.TypeOf((*MockUseCases)(nil).SignTransaction))
}

// SignTesseraTransaction mocks base method
func (m *MockUseCases) SignTesseraTransaction() ethereum.SignTesseraTransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignTesseraTransaction")
	ret0, _ := ret[0].(ethereum.SignTesseraTransactionUseCase)
	return ret0
}

// SignTesseraTransaction indicates an expected call of SignTesseraTransaction
func (mr *MockUseCasesMockRecorder) SignTesseraTransaction() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignTesseraTransaction", reflect.TypeOf((*MockUseCases)(nil).SignTesseraTransaction))
}

// MockCreateAccountUseCase is a mock of CreateAccountUseCase interface
type MockCreateAccountUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockCreateAccountUseCaseMockRecorder
}

// MockCreateAccountUseCaseMockRecorder is the mock recorder for MockCreateAccountUseCase
type MockCreateAccountUseCaseMockRecorder struct {
	mock *MockCreateAccountUseCase
}

// NewMockCreateAccountUseCase creates a new mock instance
func NewMockCreateAccountUseCase(ctrl *gomock.Controller) *MockCreateAccountUseCase {
	mock := &MockCreateAccountUseCase{ctrl: ctrl}
	mock.recorder = &MockCreateAccountUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCreateAccountUseCase) EXPECT() *MockCreateAccountUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockCreateAccountUseCase) Execute(ctx context.Context, namespace, importedPrivKey string) (*entities.ETHAccount, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, namespace, importedPrivKey)
	ret0, _ := ret[0].(*entities.ETHAccount)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockCreateAccountUseCaseMockRecorder) Execute(ctx, namespace, importedPrivKey interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCreateAccountUseCase)(nil).Execute), ctx, namespace, importedPrivKey)
}

// MockSignUseCase is a mock of SignUseCase interface
type MockSignUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSignUseCaseMockRecorder
}

// MockSignUseCaseMockRecorder is the mock recorder for MockSignUseCase
type MockSignUseCaseMockRecorder struct {
	mock *MockSignUseCase
}

// NewMockSignUseCase creates a new mock instance
func NewMockSignUseCase(ctrl *gomock.Controller) *MockSignUseCase {
	mock := &MockSignUseCase{ctrl: ctrl}
	mock.recorder = &MockSignUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignUseCase) EXPECT() *MockSignUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignUseCase) Execute(ctx context.Context, address, namespace, data string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace, data)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignUseCaseMockRecorder) Execute(ctx, address, namespace, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignUseCase)(nil).Execute), ctx, address, namespace, data)
}

// MockSignTransactionUseCase is a mock of SignTransactionUseCase interface
type MockSignTransactionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSignTransactionUseCaseMockRecorder
}

// MockSignTransactionUseCaseMockRecorder is the mock recorder for MockSignTransactionUseCase
type MockSignTransactionUseCaseMockRecorder struct {
	mock *MockSignTransactionUseCase
}

// NewMockSignTransactionUseCase creates a new mock instance
func NewMockSignTransactionUseCase(ctrl *gomock.Controller) *MockSignTransactionUseCase {
	mock := &MockSignTransactionUseCase{ctrl: ctrl}
	mock.recorder = &MockSignTransactionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignTransactionUseCase) EXPECT() *MockSignTransactionUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignTransactionUseCase) Execute(ctx context.Context, address, namespace string, chainID *big.Int, tx *types0.Transaction) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace, chainID, tx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignTransactionUseCaseMockRecorder) Execute(ctx, address, namespace, chainID, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignTransactionUseCase)(nil).Execute), ctx, address, namespace, chainID, tx)
}

// MockSignTesseraTransactionUseCase is a mock of SignTesseraTransactionUseCase interface
type MockSignTesseraTransactionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSignTesseraTransactionUseCaseMockRecorder
}

// MockSignTesseraTransactionUseCaseMockRecorder is the mock recorder for MockSignTesseraTransactionUseCase
type MockSignTesseraTransactionUseCaseMockRecorder struct {
	mock *MockSignTesseraTransactionUseCase
}

// NewMockSignTesseraTransactionUseCase creates a new mock instance
func NewMockSignTesseraTransactionUseCase(ctrl *gomock.Controller) *MockSignTesseraTransactionUseCase {
	mock := &MockSignTesseraTransactionUseCase{ctrl: ctrl}
	mock.recorder = &MockSignTesseraTransactionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignTesseraTransactionUseCase) EXPECT() *MockSignTesseraTransactionUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignTesseraTransactionUseCase) Execute(ctx context.Context, address, namespace string, tx *types.Transaction) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace, tx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignTesseraTransactionUseCaseMockRecorder) Execute(ctx, address, namespace, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignTesseraTransactionUseCase)(nil).Execute), ctx, address, namespace, tx)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: orm.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	store "gitlab.com/ConsenSys/client/fr/core-stack/orchestrate.git/services/transaction-scheduler/store"
	models "gitlab.com/ConsenSys/client/fr/core-stack/orchestrate.git/services/transaction-scheduler/store/models"
	reflect "reflect"
)

// MockORM is a mock of ORM interface.
type MockORM struct {
	ctrl     *gomock.Controller
	recorder *MockORMMockRecorder
}

// MockORMMockRecorder is the mock recorder for MockORM.
type MockORMMockRecorder struct {
	mock *MockORM
}

// NewMockORM creates a new mock instance.
func NewMockORM(ctrl *gomock.Controller) *MockORM {
	mock := &MockORM{ctrl: ctrl}
	mock.recorder = &MockORMMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockORM) EXPECT() *MockORMMockRecorder {
	return m.recorder
}

// InsertOrUpdateJob mocks base method.
func (m *MockORM) InsertOrUpdateJob(ctx context.Context, db store.DB, job *models.Job) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertOrUpdateJob", ctx, db, job)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertOrUpdateJob indicates an expected call of InsertOrUpdateJob.
func (mr *MockORMMockRecorder) InsertOrUpdateJob(ctx, db, job interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateJob", reflect.TypeOf((*MockORM)(nil).InsertOrUpdateJob), ctx, db, job)
}

// InsertLog mocks base method.
func (m *MockORM) InsertLog(ctx context.Context, db store.DB, log *models.Log) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertLog", ctx, db, log)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertLog indicates an expected call of InsertLog.
func (mr *MockORMMockRecorder) InsertLog(ctx, db, log interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertLog", reflect.TypeOf((*MockORM)(nil).InsertLog), ctx, db, log)
}

// InsertSchedule mocks base method.
func (m *MockORM) InsertSchedule(ctx context.Context, db store.DB, schedule *models.Schedule) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertSchedule", ctx, db, schedule)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertSchedule indicates an expected call of InsertSchedule.
func (mr *MockORMMockRecorder) InsertSchedule(ctx, db, schedule interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertSchedule", reflect.TypeOf((*MockORM)(nil).InsertSchedule), ctx, db, schedule)
}

// FetchScheduleByID mocks base method.
func (m *MockORM) FetchScheduleByID(ctx context.Context, db store.DB, scheduleID int) (*models.Schedule, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchScheduleByID", ctx, db, scheduleID)
	ret0, _ := ret[0].(*models.Schedule)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchScheduleByID indicates an expected call of FetchScheduleByID.
func (mr *MockORMMockRecorder) FetchScheduleByID(ctx, db, scheduleID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchScheduleByID", reflect.TypeOf((*MockORM)(nil).FetchScheduleByID), ctx, db, scheduleID)
}

// InsertOrUpdateTransaction mocks base method.
func (m *MockORM) InsertOrUpdateTransaction(ctx context.Context, db store.DB, tx *models.Transaction) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertOrUpdateTransaction", ctx, db, tx)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertOrUpdateTransaction indicates an expected call of InsertOrUpdateTransaction.
func (mr *MockORMMockRecorder) InsertOrUpdateTransaction(ctx, db, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateTransaction", reflect.TypeOf((*MockORM)(nil).InsertOrUpdateTransaction), ctx, db, tx)
}

// FetchScheduleByUUID mocks base method.
func (m *MockORM) FetchScheduleByUUID(ctx context.Context, db store.DB, scheduleUUID, tenantID string) (*models.Schedule, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchScheduleByUUID", ctx, db, scheduleUUID, tenantID)
	ret0, _ := ret[0].(*models.Schedule)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchScheduleByUUID indicates an expected call of FetchScheduleByUUID.
func (mr *MockORMMockRecorder) FetchScheduleByUUID(ctx, db, scheduleUUID, tenantID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchScheduleByUUID", reflect.TypeOf((*MockORM)(nil).FetchScheduleByUUID), ctx, db, scheduleUUID, tenantID)
}

// FetchAllSchedules mocks base method.
func (m *MockORM) FetchAllSchedules(ctx context.Context, db store.DB, tenantID string) ([]*models.Schedule, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchAllSchedules", ctx, db, tenantID)
	ret0, _ := ret[0].([]*models.Schedule)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchAllSchedules indicates an expected call of FetchAllSchedules.
func (mr *MockORMMockRecorder) FetchAllSchedules(ctx, db, tenantID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchAllSchedules", reflect.TypeOf((*MockORM)(nil).FetchAllSchedules), ctx, db, tenantID)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: store.pb.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	envelope_store "gitlab.com/ConsenSys/client/fr/core-stack/orchestrate.git/types/envelope-store"
	grpc "google.golang.org/grpc"
	reflect "reflect"
)

// MockEnvelopeStoreClient is a mock of EnvelopeStoreClient interface
type MockEnvelopeStoreClient struct {
	ctrl     *gomock.Controller
	recorder *MockEnvelopeStoreClientMockRecorder
}

// MockEnvelopeStoreClientMockRecorder is the mock recorder for MockEnvelopeStoreClient
type MockEnvelopeStoreClientMockRecorder struct {
	mock *MockEnvelopeStoreClient
}

// NewMockEnvelopeStoreClient creates a new mock instance
func NewMockEnvelopeStoreClient(ctrl *gomock.Controller) *MockEnvelopeStoreClient {
	mock := &MockEnvelopeStoreClient{ctrl: ctrl}
	mock.recorder = &MockEnvelopeStoreClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEnvelopeStoreClient) EXPECT() *MockEnvelopeStoreClientMockRecorder {
	return m.recorder
}

// Store mocks base method
func (m *MockEnvelopeStoreClient) Store(ctx context.Context, in *envelope_store.StoreRequest, opts ...grpc.CallOption) (*envelope_store.StoreResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Store", varargs...)
	ret0, _ := ret[0].(*envelope_store.StoreResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Store indicates an expected call of Store
func (mr *MockEnvelopeStoreClientMockRecorder) Store(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockEnvelopeStoreClient)(nil).Store), varargs...)
}

// LoadByID mocks base method
func (m *MockEnvelopeStoreClient) LoadByID(ctx context.Context, in *envelope_store.LoadByIDRequest, opts ...grpc.CallOption) (*envelope_store.StoreResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadByID", varargs...)
	ret0, _ := ret[0].(*envelope_store.StoreResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadByID indicates an expected call of LoadByID
func (mr *MockEnvelopeStoreClientMockRecorder) LoadByID(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadByID", reflect.TypeOf((*MockEnvelopeStoreClient)(nil).LoadByID), varargs...)
}

// LoadByTxHash mocks base method
func (m *MockEnvelopeStoreClient) LoadByTxHash(ctx context.Context, in *envelope_store.LoadByTxHashRequest, opts ...grpc.CallOption) (*envelope_store.StoreResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadByTxHash", varargs...)
	ret0, _ := ret[0].(*envelope_store.StoreResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadByTxHash indicates an expected call of LoadByTxHash
func (mr *MockEnvelopeStoreClientMockRecorder) LoadByTxHash(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadByTxHash", reflect.TypeOf((*MockEnvelopeStoreClient)(nil).LoadByTxHash), varargs...)
}

// SetStatus mocks base method
func (m *MockEnvelopeStoreClient) SetStatus(ctx context.Context, in *envelope_store.SetStatusRequest, opts ...grpc.CallOption) (*envelope_store.StatusResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetStatus", varargs...)
	ret0, _ := ret[0].(*envelope_store.StatusResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetStatus indicates an expected call of SetStatus
func (mr *MockEnvelopeStoreClientMockRecorder) SetStatus(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatus", reflect.TypeOf((*MockEnvelopeStoreClient)(nil).SetStatus), varargs...)
}

// LoadPending mocks base method
func (m *MockEnvelopeStoreClient) LoadPending(ctx context.Context, in *envelope_store.LoadPendingRequest, opts ...grpc.CallOption) (*envelope_store.LoadPendingResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadPending", varargs...)
	ret0, _ := ret[0].(*envelope_store.LoadPendingResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadPending indicates an expected call of LoadPending
func (mr *MockEnvelopeStoreClientMockRecorder) LoadPending(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadPending", reflect.TypeOf((*MockEnvelopeStoreClient)(nil).LoadPending), varargs...)
}

// MockEnvelopeStoreServer is a mock of EnvelopeStoreServer interface
type MockEnvelopeStoreServer struct {
	ctrl     *gomock.Controller
	recorder *MockEnvelopeStoreServerMockRecorder
}

// MockEnvelopeStoreServerMockRecorder is the mock recorder for MockEnvelopeStoreServer
type MockEnvelopeStoreServerMockRecorder struct {
	mock *MockEnvelopeStoreServer
}

// NewMockEnvelopeStoreServer creates a new mock instance
func NewMockEnvelopeStoreServer(ctrl *gomock.Controller) *MockEnvelopeStoreServer {
	mock := &MockEnvelopeStoreServer{ctrl: ctrl}
	mock.recorder = &MockEnvelopeStoreServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEnvelopeStoreServer) EXPECT() *MockEnvelopeStoreServerMockRecorder {
	return m.recorder
}

// Store mocks base method
func (m *MockEnvelopeStoreServer) Store(arg0 context.Context, arg1 *envelope_store.StoreRequest) (*envelope_store.StoreResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", arg0, arg1)
	ret0, _ := ret[0].(*envelope_store.StoreResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Store indicates an expected call of Store
func (mr *MockEnvelopeStoreServerMockRecorder) Store(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockEnvelopeStoreServer)(nil).Store), arg0, arg1)
}

// LoadByID mocks base method
func (m *MockEnvelopeStoreServer) LoadByID(arg0 context.Context, arg1 *envelope_store.LoadByIDRequest) (*envelope_store.StoreResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadByID", arg0, arg1)
	ret0, _ := ret[0].(*envelope_store.StoreResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadByID indicates an expected call of LoadByID
func (mr *MockEnvelopeStoreServerMockRecorder) LoadByID(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadByID", reflect.TypeOf((*MockEnvelopeStoreServer)(nil).LoadByID), arg0, arg1)
}

// LoadByTxHash mocks base method
func (m *MockEnvelopeStoreServer) LoadByTxHash(arg0 context.Context, arg1 *envelope_store.LoadByTxHashRequest) (*envelope_store.StoreResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadByTxHash", arg0, arg1)
	ret0, _ := ret[0].(*envelope_store.StoreResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadByTxHash indicates an expected call of LoadByTxHash
func (mr *MockEnvelopeStoreServerMockRecorder) LoadByTxHash(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadByTxHash", reflect.TypeOf((*MockEnvelopeStoreServer)(nil).LoadByTxHash), arg0, arg1)
}

// SetStatus mocks base method
func (m *MockEnvelopeStoreServer) SetStatus(arg0 context.Context, arg1 *envelope_store.SetStatusRequest) (*envelope_store.StatusResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetStatus", arg0, arg1)
	ret0, _ := ret[0].(*envelope_store.StatusResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetStatus indicates an expected call of SetStatus
func (mr *MockEnvelopeStoreServerMockRecorder) SetStatus(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatus", reflect.TypeOf((*MockEnvelopeStoreServer)(nil).SetStatus), arg0, arg1)
}

// LoadPending mocks base method
func (m *MockEnvelopeStoreServer) LoadPending(arg0 context.Context, arg1 *envelope_store.LoadPendingRequest) (*envelope_store.LoadPendingResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadPending", arg0, arg1)
	ret0, _ := ret[0].(*envelope_store.LoadPendingResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadPending indicates an expected call of LoadPending
func (mr *MockEnvelopeStoreServerMockRecorder) LoadPending(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadPending", reflect.TypeOf((*MockEnvelopeStoreServer)(nil).LoadPending), arg0, arg1)
}
